[[{"l":"Welcome"},{"l":"Quail","p":["Bird-brained swerve drive utility.","To use quail, you need a few things. The first is swerve modules. I don't care where your swerve modules are. They could be 52 miles apart and in the shape of a pentagon and quail would still work.","The second thing you need is a little knowledge of Java. You should be able to:","use a PID controller","use subclasses","make your motors spin","But, most importantly, you need a desire for freedom.","Get Started"]}],[{"i":"installation---its-not-that-hard","l":"Installation - It's not that hard","p":["Quail is in its alpha stages, some features are not stable and may not work as intended. If you find a bug, please report it on here."]},{"l":"Into an Existing Project","p":["Add JitPack to your build file","Add the dependency","Figure it out yourself","Here is the jitpack link"]},{"l":"FTC Quickstart","p":["coming soon™"]}],[{"l":"Math"},{"i":"terminology","l":"Terminology:","p":["Forwards kinematics: determining the robot's position based on the module angles and speeds","Reverse kinematics: determining the module angles and speeds based on a desired robot movement","Module state: the module's angle and speed (vector)","Module position: the module's position relative to the robot's center of rotation","Robot position: the robot's position relative to the field"]},{"i":"reverse-kinematics-general","l":"Reverse Kinematics (general)","p":["From a desired robot movement (Δ position), we can calculate the module state for each module.","To do so, we begin with the translation component of the desired robot movement, vector RG(movement of robot relative to the ground).","For translation, each module state, mi, is equal to the robot's movement relative to the ground ( miG) plus the module's movement relative to the robot of rotation ( miR).","mi= miG+ miR","It should then follow that miR can be calculated easily:","its angle must be perpendicular to the module's position vector","its magnitude is equal to the robot's rotation speed times the module's distance from the center of rotation"]},{"i":"reverse-kinematics-differential-swerve","l":"Reverse Kinematics (Differential Swerve)","p":["Please note that in some differential swerve setups one motor's rotation is reversed, which will require inversion of its veocity and position","With differential swerve, the module's angular velocity is equal to the sum of the two motor velocities, and the module's linear velocity is equal to the difference of the two motor velocities.","VA= Vm1+ Vm2","VL= Vm1- Vm2","However, this does not account for gear ratios. Accounting for gear ratios, we get:","RA VA= Vm1+ Vm2","RL VL= Vm1- Vm2","Where RA and RL are the angular and linear gear ratios, respectively.","A simple manipulation gives:","Vm1= ( RA VA+ RL VL) / 2","Vm2= ( RA VA- RL VL) / 2"]},{"i":"forwards-kinematics-general","l":"Forwards Kinematics (general)","p":["Good luck.","coming soon™"]},{"i":"forwards-kinematics-differential-swerve","l":"Forwards Kinematics (Differential Swerve)","p":["Please note that in some differential swerve setups one motor's rotation is reversed, which will require inversion of its veocity and position","Knowing the distance that a module has traveled is not very useful. If you find a use for it, it can be calculated in a similar method as follows.","The angular distance that a module has traveled--its angle relative to its starting position-- is useful.","To calculate angular distance, we can begin with the equation for differential swerve module angular velocity:","RA VA= Vm1+ Vm2","RA is a constant, so we can integrate both sides with respect to time to get:","RA θA= θm1+ θm2+ C","Where ΔA is the angule of the module, θm1 and θm2 are the angles of the motors, and C is the initial position of the module.","This calculation is usually not as precise as using an absolute encoder (due to backlash) but is generally good enough."]}],[{"i":"#","p":["Abstract class for two wheel odometry"]},{"i":"twowheellocalizer---abstract-class-for-two-wheel-odometry","l":"TwoWheelLocalizer - Abstract Class For Two Wheel Odometry"},{"l":"Class Details","p":["I could be useful with this message, but that's a lot of work."]},{"l":"Usage","p":["ABSTRACT FOP A REASON!","I recommend creating some form of interface on top of this class to make it easier to use. Have a periodic() or update(), a getPos() or getPose(), and a setPos() or setPose() method.","Required Methods:","Override getHeading()","Override getWheelPositions()","A 'periodic' method to call TwoWheelLocalizer.update(), eg., super.update()","Recommended Methods:","Convert encoder ticks to unit of measurement","A method to return the Pose2d of the bot, utilize TwoWheelLocalizer.getPoseEstimate(), eg., super.getPoseEstimate()","A method to set the Pose2d of the bot, utilize TwoWheelLocalizer.setPoseEstimate(), eg., super.setPoseEstimate()"]}],[{"i":"swerve-odometry---a-swerve-drive-odometry-class","l":"Swerve Odometry - A Swerve Drive Odometry Class"},{"l":"Class Summary","p":["You should probably give it what it wants. Using the swerveDrive constructor is recommended."]},{"l":"Usage","p":["Just do it™ - Nike. Use calculateOdometry() and calculateFastOdometry with the module vectors (current angle and current velocity). Use this to updateOdometryDelta().","If you want to, you can get module vectors using extractModuleVectors() and pass in the swerveDrive."]}],[{"l":"Vision"},{"i":"coming-soon","l":"Coming Soon™"}],[{"i":"path---a-set-of-points","l":"Path - A Set of Points"},{"l":"Class Summary","p":["If you don't know what a path is, swerve might not be for you."]},{"l":"Usage","p":["You make an ArrayList, and you pass it into the class. It represents the points that the robot will pass through. If you don't like Pose2d and prefer to use lists for some reason, Pose2d.fromList(double[]) exists. It takes 3 doubles: x, y, and theta. Have fun :D","Just pass the current gyro angle into the Pose2d s if you don't want the robot to rotate. It's also in radians because I'm not a monster.","You can cycle through the points using a few things, like getCurrentPoint(), getNextPoint(), and getPointRelativeToCurrent().","Because some users had difficulty with these, we added some builtin nearest point utils: nearestPointIndex() and nearestPoint(), pretty cool, huh?"]}],[{"i":"pathfollower---it-follows-paths","l":"PathFollower - It Follows Paths"},{"l":"Class Summary","p":["Self explanatory"]},{"l":"Usage","p":["This one is simple for once. Give the class what it needs. Make sure you aren't trying to turn right at 999deg/s unless your drivetrain supports it. PID is also really cool, it allows you to actually turn accurately, you should tune that. Precision is kinda important, decide how precise you want to be :D","To set a new path, use setPath(). You can calculate the next movement each loop cycle using calculateNextDriveMovement(), it returns a robotMovement that you can feed into swerveDrive.move(). The path is (hopefully) completed when the isFinished() method returns true. We do try to make your life easier sometimes. You could also go off the rails and do something else with it if you want, but that's not recommended. The method also deals with getting the pose from your localizer of choice, so that's nice."]}],[{"i":"pathsequencefollower---following-sequences-of-paths","l":"PathSequenceFollower - Following Sequences of Paths"},{"i":"deprecated---coming-soon","l":"Deprecated - Coming Soon™"},{"l":"Class Summary","p":["Neat, huh?"]},{"l":"Usage","p":["This class strings together a mix of paths and \"markers\". These two things are consdered \"segments\". Think of markers as a point where an action should occur. Currently they are synchronous only, meaning the robot will wait until the previous segment has completed before running the next segment. If you can't understand that, then you shuoldn't be using this class.","When initialized your sequence follower, you will need to give it a sequence to follow, these can be added onto at any time. To add segments to your sequence any of these methods can be used:","It is important to understand what these do.","Using .addPath() will add the specified path to the sequence.","Using .addDisplacementMarker() run the specified action when the marker is reached.","Using .addLocalTemporalMarker() will run the specified action after the specified time has passed since the start of THIS segment (since the end of the previous segment).","You should string these methods together, eg:","Don't forget about lambda expressions (if you don't know what they are, google it) for runnables, they make your life so much easier."]},{"i":"do-not-run-blocking-methods-in-markers","l":"DO NOT RUN BLOCKING METHODS IN MARKERS."},{"i":"when-using-markers-it-is-super-important-to-not-use-sleep-or-any-other-blocking-methods-it-will-pause-everything-under-the-sun","l":"When using markers, it is super important to not use sleep() or any other blocking methods, it will pause everything under the sun.","p":["You should use .addLocalTemporalMarker() to wait. An example use could be when you want to instruct a servo to go to a position, but wait 1 second before moving to the next segment after commanding the servo (grabbing something). You don't have to do this per say, but if you want a working autonomous, you should.","To run this follower, you should probably call followPathSequence() in your loop and feed the robotMovement it returns into your drivetrain. You can also use isFinished() to check if the sequence is finished. Again, all of this is optional, I just think it's a good idea to use it.","This class is still kinda goofy, report any issues you find"]}],[{"i":"swerve-drive---class-for-your-swerve-drive","l":"Swerve Drive - Class For Your Swerve Drive"},{"l":"Class Summary","p":["Where swerveModules is a list of swerve modules. Crazy, right?"]},{"l":"Usage","p":["This one is fun","Obviously, this class represents a swerve drive. It is designed to be inherited from, it will technically when not inherited from, but it is not recommended.","You might want a few methods:","Reset gyro, both from controller and potentially vision (not recommended)","Reset module positions (absolute encoders are amazing)","Acceleration limiting (while walls are fun to hit, it is not recommended. May come soon to quail)","Typical Usage:","Create a list of swerve modules that inherit from ( differentialSwerveModuleBase or swerveModuleBase)","Create a swerveDrive object with the list of the swerve modules","every time you want to move, call move() with your desired movement vector and rotation speed","Get the module vectors from the swerve module sensors and pass them into swerveOdometry or just use TwoWheelLocalizer if you like deadwheels","You should be able to skip the last step if using move(), it will normalize the vectors for you.","If for some reason you don't want to use move(), you can make your life harder and use calculateMoveAngles(see javadoc) and then normalize those vectors and pass them into the modules."]}],[{"i":"swervemodulebase---represents-a-swerve-module","l":"SwerveModuleBase - Represents a Swerve Module"},{"l":"Class Summary","p":["Self explanatory"]},{"l":"Usage","p":["The base of everything quail (almost). Represents a swerve module (coaxial, or can be extended to non-coaxial).","This class is designed to be inherited from. You need to override the setAngle() and setRawSpeed methods to set the module's angle and wheel velocity, respectively. You could also probably include a method to reset your module position (preferably using absolute encoders geared 1:1 with the module heading).","Make sure that you're accounting for your gear ratios. It is recommended that you configure swerveDrive call set() on all of your modules."]}],[{"i":"differential-swerve-module-base---swerve-module-but-differential","l":"Differential Swerve Module Base - Swerve Module, But Differential"},{"l":"Class Summary","p":["Support for integral swerve modules will come in version 3.0.0"]},{"l":"Usage","p":["ABSTRACT FOR A GOOD REASON FOR ONCE","Suggested Usage: Create a method to set the motor powers/module that takes in a Vec2d. This method should use calculateMotorSpeeds, some PID magic, normalizing powers to your maximum allowable motor power, and actually setting your motor powers.","It is highly recommended that you feed your motors and encoders into this class. Absolute encoders are great, but your motor's relative encoders can work if you rub your braincells and do some math. You will need your drive and steering ratios if you decide to go the math route. Using a PID controller for getting the rotation speed is recommended, but not required. Getting the wheel speed is just Vec2d.getLength(). You should also probably do some form of \"wheel flipping\" to optimize turns, eg., instead of turning the module 180 degrees, just invert the drive speed (this is supported in the library). Recommendations, not requirements."]}]]