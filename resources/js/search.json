[[{"l":"Welcome"},{"l":"Quail","p":["Bird-brained swerve drive utility.","To use quail, you need a few things. The first is swerve modules. I don't care where your swerve modules are. They could be 52 miles apart and in the shape of a pentagon and quail would still work.","The second thing you need is a little knowledge of Java. You should be able to:","use a PID controller","use subclasses","make your motors spin","But, most importantly, you need a desire for freedom.","Get Started"]}],[{"l":"Installation"},{"l":"Via Jitpack"},{"l":"Into an Existing Project","p":["Add JitPack to your build file","Add the dependency","Figure it out yourself","Here is the jitpack link","Add the submodule","This will clone a copy of Quail into your project at repositories/quail.","Symlink the Quail module into your project","On Windows:","This will create a symlink to the Quail module in your project.","To update the module:"]},{"l":"FTC Quickstart","p":["coming soon™"]}],[{"l":"Math","p":["Explanations for how the math works. You don't need to know this to use the library, but it might help you understand what's going on."]},{"i":"terminology","l":"Terminology:","p":["Forwards kinematics: determining the robot's position based on the module angles and speeds","Reverse kinematics: determining the module angles and speeds based on a desired robot movement","Module state: the module's angle and speed (vector)","Module position: the module's position relative to the robot's center of rotation","Robot position: the robot's position relative to the field"]},{"i":"reverse-kinematics-drivetrain","l":"Reverse Kinematics (drivetrain)","p":["From a desired robot movement (Δ position), we can calculate the module state for each module.","To do so, we begin with the translation component of the desired robot movement, vector RG(movement of robot relative to the ground).","For translation, each module state, mi, is equal to the robot's movement relative to the ground ( miG) plus the module's movement relative to the robot of rotation ( miR).","mi= miG+ miR","It should then follow that miR can be calculated easily:","its angle must be perpendicular to the module's position vector","its magnitude is equal to the robot's rotation speed times the module's distance from the center of rotation"]},{"i":"reverse-kinematics-differential-swerve","l":"Reverse Kinematics (differential swerve)","p":["Please note that in some differential swerve setups one motor's rotation is reversed, which will require inversion of its veocity and position","With differential swerve, the module's angular velocity is equal to the sum of the two motor velocities, and the module's linear velocity is equal to the difference of the two motor velocities.","VA= Vm1+ Vm2","VL= Vm1- Vm2","However, this does not account for gear ratios. Accounting for gear ratios, we get:","RA VA= Vm1+ Vm2","RL VL= Vm1- Vm2","Where RA and RL are the angular and linear gear ratios, respectively.","A simple manipulation gives:","Vm1= ( RA VA+ RL VL) / 2","Vm2= ( RA VA- RL VL) / 2"]},{"i":"forwards-kinematics-drivetrain","l":"Forwards Kinematics (drivetrain)","p":["This method involves taking velocity vectors from each module, and combining that information with the module positions to obtain the robot velocity, which can then be integrated to find a delta position."]},{"l":"The fast way","p":["If your modules are in a shape such that their average position is the center of the robot, then you can use this method.","\"average modules position in center of robot\" means one of the following:","your modules are in a geometric regular shape (square, regular pentagon, equilateral triangle, straight line with robot center bisecting it)","the sum of the module position vectors is zero (rectangle and some other shapes meet this requirement)","Because the rotation vector of each module will cancel out, the robot velocity will be equal to the average of the module velocities."]},{"i":"the-slow-but-more-flexible-way","l":"The slow (but more flexible) way","p":["What happens if your modules do not meet the above requirements? This code has been implemented into quail, but the math behind it is rather complex.","coming soon™"]},{"i":"forwards-kinematics-sifferential-swerve-per-module","l":"Forwards Kinematics (sifferential swerve per-module)","p":["Please note that in some differential swerve setups one motor's rotation is reversed, which will require inversion of its velocity and position","Knowing the distance that a module has traveled is not very useful. If you find a use for it, it can be calculated in a similar method as follows.","The angular distance that a module has traveled--its angle relative to its starting position-- is useful.","To calculate angular distance, we can begin with the equation for differential swerve module angular velocity:","RA VA= Vm1+ Vm2","RA is a constant, so we can integrate both sides with respect to time to get:","RA θA= θm1+ θm2+ C","Where ΔA is the angule of the module, θm1 and θm2 are the angles of the motors, and C is the initial position of the module.","This calculation is usually not as precise as using an absolute encoder (due to backlash) but is generally good enough."]}],[{"i":"#","p":["Abstract class for two wheel odometry"]},{"i":"twowheellocalizer---abstract-class-for-two-wheel-odometry","l":"TwoWheelLocalizer - Abstract Class For Two Wheel Odometry"},{"l":"Class Details","p":["I could be useful with this message, but that's a lot of work."]},{"l":"Usage","p":["ABSTRACT FOP A REASON!","I recommend creating some form of interface on top of this class to make it easier to use. Have a periodic() or update(), a getPos() or getPose(), and a setPos() or setPose() method.","Required Methods:","Override getHeading()","Override getWheelPositions()","A 'periodic' method to call TwoWheelLocalizer.update(), eg., super.update()","Recommended Methods:","Convert encoder ticks to unit of measurement","A method to return the Pose2d of the bot, utilize TwoWheelLocalizer.getPoseEstimate(), eg., super.getPoseEstimate()","A method to set the Pose2d of the bot, utilize TwoWheelLocalizer.setPoseEstimate(), eg., super.setPoseEstimate()"]}],[{"i":"swerve-odometry---a-swerve-drive-odometry-class","l":"Swerve Odometry - A Swerve Drive Odometry Class"},{"l":"Class Summary","p":["Instantiate a new swerveOdometry object with the module positions of your swerve drive. You can also pass in a swerveDrive object to get the position vectors from that."]},{"l":"Usage","p":["Use calculateOdometry() and calculateFastOdometry() with the module vectors (obtained from the encoders on the modules). Use this to updateOdometryDelta() after scaling by your looptime and rotates."]},{"l":"Example","p":["calculateFastOdometry() only works if your modules are in a regular geometric shape. If they are, it is much faster than calculateOdometry()."]}],[{"l":"Vision","p":["For help with vision, Quail provides a Kalman filter, implemented as a mostly drop-in replacement for the other Localizer classes."]},{"l":"Background","p":["Many robots have multiple methods of getting a field pose, including vision and wheel odometry. The Kalman Filter is a method for fusing the two sensors.","The Kalman Filter is particularly useful in situations where the robot's environment is noisy or uncertain. Vision data is typically quite noisy and can jump wildly, deteriorating pathplanning attempts. By fusing data from multiple sources, it can provide a more precise and stable estimate of the robot's position."]},{"l":"Usage","p":["First, one must create a KalmanFilterLocalizer with the robot starting position and robot looptime (50ms default for FTC, 20ms default in FRC)","The initial position does not matter if the vision reports a position on startup","After the localizer has been created, simply call the KalmanFilterLocalizer.update() with the vision pose, the field-relative velocity, how much to trust the vision, and the current timestamp in milliseconds."]},{"l":"Math","p":["At any given time/tick ( t) we are trying to estimate our position, we do this through a weighted average of a kalman estimate and pose data from our vision system. Because the pose that the limelight sends us can be four ticks behind the current pose, we compensate for this by applying basic dead reckoning given the last n recorded velocities since we last got a limelight update","\\hat v","Velocity vector","P_k(t)","Kalman estimate at a given tick t","P_v(t)","Vision position estimate at given tick (t)","\\hat P(t)","Combined estimate postition","w","How much weight we “trust” the vision estimate","\\dot t","How many ticks since we last got a limelight update"]},{"l":"Update Rule","p":["Because we cannot do an actual integral in our periodic function, we will keep a buffer of the last n velocity values and take the sum of those when calculating the position from the limelight.","In in this case is the maximum number of ticks between limelight updates"]},{"l":"Pseudocode"}],[{"i":"path---a-set-of-points","l":"Path - A Set of Points"},{"l":"Class Summary","p":["Represents a path..."]},{"l":"Usage","p":["You make an ArrayList, and you pass it into the class. It represents the points that the robot will pass through. If you don't like Pose2d and prefer to use lists for some reason, Pose2d.fromList(double[]) exists. It takes 3 doubles: x, y, and theta. Have fun :D","Just pass the current gyro angle into the Pose2d s if you don't want the robot to rotate. It's also in radians like everything else in Quail.","You can cycle through the points using a few things, like getCurrentPoint(), getNextPoint(), and getPointRelativeToCurrent().","Because some users had difficulty with these, we added some builtin nearest point utils: nearestPointIndex() and nearestPoint()."]}],[{"i":"pathfollower---it-follows-paths","l":"PathFollower - It Follows Paths"},{"l":"Class Summary","p":["Follows paths."]},{"l":"Usage","p":["Make sure you aren't trying to turn right at 999deg/s unless your drivetrain supports it. PID is also really cool but needs to be tuned.","To set a new path, use setPath(). You can calculate the next movement each loop cycle using calculateNextDriveMovement(), it returns a robotMovement that you can feed into swerveDrive.move(). The path is (hopefully) completed when the isFinished() method returns true. We do try to make your life easier sometimes. You could also go off the rails and do something else with it if you want, but that's not recommended. The method also deals with getting the pose from your localizer of choice, so that's nice."]}],[{"i":"pathsequencefollower---following-sequences-of-paths","l":"PathSequenceFollower - Following Sequences of Paths"},{"i":"deprecated---coming-soon","l":"Deprecated - Coming Soon™"},{"l":"Class Summary","p":["Neat, huh?","DO NOT USE - THIS FILE DESCRIBES FEATURES NOT YET WORKING"]},{"l":"Usage","p":["This class strings together a mix of paths and \"markers\". These two things are consdered \"segments\". Think of markers as a point where an action should occur. Currently they are synchronous only, meaning the robot will wait until the previous segment has completed before running the next segment. If you can't understand that, then you shuoldn't be using this class.","When initialized your sequence follower, you will need to give it a sequence to follow, these can be added onto at any time. To add segments to your sequence any of these methods can be used:","It is important to understand what these do.","Using .addPath() will add the specified path to the sequence.","Using .addDisplacementMarker() run the specified action when the marker is reached.","Using .addLocalTemporalMarker() will run the specified action after the specified time has passed since the start of THIS segment (since the end of the previous segment).","You should string these methods together, eg:","Don't forget about lambda expressions (if you don't know what they are, google it) for runnables, they make your life so much easier."]},{"i":"do-not-run-blocking-methods-in-markers","l":"DO NOT RUN BLOCKING METHODS IN MARKERS."},{"i":"when-using-markers-it-is-super-important-to-not-use-sleep-or-any-other-blocking-methods-it-will-pause-everything-under-the-sun","l":"When using markers, it is super important to not use sleep() or any other blocking methods, it will pause everything under the sun.","p":["You should use .addLocalTemporalMarker() to wait. An example use could be when you want to instruct a servo to go to a position, but wait 1 second before moving to the next segment after commanding the servo (grabbing something). You don't have to do this per say, but if you want a working autonomous, you should.","To run this follower, you should probably call followPathSequence() in your loop and feed the robotMovement it returns into your drivetrain. You can also use isFinished() to check if the sequence is finished. Again, all of this is optional, I just think it's a good idea to use it.","This class is still kinda goofy, report any issues you find"]}],[{"i":"swerve-drive---class-for-your-swerve-drive","l":"Swerve Drive - Class For Your Swerve Drive"},{"l":"Class Summary"},{"l":"Usage","p":["This class represents a swerve drive. It is designed to be inherited from; it will technically work when not inherited from, but it is not recommended.","You might want a few methods:","Reset gyro, both from controller and potentially vision","Reset module positions (absolute encoders are amazing)","Acceleration limiting (while walls are fun to hit, it is not recommended. May come soon to quail)","Typical Usage:","Create a list of swerve modules that inherit from ( differentialSwerveModuleBase or swerveModuleBase)","Create a swerveDrive object with the list of the swerve modules","every time you want to move, call move() with your desired movement vector and rotation speed","Get the module vectors from the swerve module sensors and pass them into swerveOdometry or just use TwoWheelLocalizer if you like deadwheels","If for some reason you don't want to use move(), you can use calculateMoveAngles(see javadoc) and then normalize those vectors and pass them into the modules."]}],[{"i":"swervemodulebase---represents-a-swerve-module","l":"SwerveModuleBase - Represents a Swerve Module"},{"l":"Class Summary","p":["Self explanatory"]},{"l":"Usage","p":["The base of everything quail (almost). Represents a swerve module (coaxial, or can be extended to non-coaxial).","This class is designed to be inherited from. You need to override the setAngle() and setRawSpeed() methods to set the module's angle and wheel velocity, respectively. You could also probably include a method to reset your module position (preferably using absolute encoders geared 1:1 with the module heading).","Make sure that you're accounting for your gear ratios."]}],[{"i":"differential-swerve-module-base---swerve-module-but-differential","l":"Differential Swerve Module Base - Swerve Module, But Differential"},{"l":"Class Summary","p":["Support for integral swerve modules will come in version 3.0.0"]},{"l":"Usage","p":["Create a method to set the motor powers/module that takes in a Vec2d. This method should use calculateMotorSpeeds, some PID magic, normalizing powers to your maximum allowable motor power, and actually setting your motor powers.","It is highly recommended that you feed your motors and encoders into this class. Absolute encoders are great, but your motor's relative encoders can work if needed You will need your drive and steering ratios. Using a PID controller for getting the rotation speed is recommended. Getting the wheel speed is just Vec2d.getLength(). You should also probably do some form of \"wheel flipping\" to optimize turns, eg., instead of turning the module 180 degrees, just invert the drive speed (this is supported in the library)."]}]]